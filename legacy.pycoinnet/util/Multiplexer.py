
import asyncio
import logging

from weakref import WeakSet

logger = logging.getLogger(__name__)


class Multiplexer:
    """
    This class is used to copy a queue to multiple queues.
    It fetched objects from the coroutine get_next_obj
    and puts them into queues generated by "new_q".
    This allows multiple tasks to each get a crack at events.
    """
    def __init__(self, get_next_obj, loop=None):
        loop = loop or asyncio.get_event_loop()
        self.loop = loop
        self.get_next_obj = get_next_obj
        self.queue_set = WeakSet()
        self.event_queue_nonempty = asyncio.Event(loop=loop)
        self.is_running = True

        @asyncio.coroutine
        def f():
            while self.is_running:
                item = yield from self.get_next_obj()
                if len(self.queue_set) == 0:
                    self.event_queue_nonempty.clear()
                    yield from self.event_queue_nonempty.wait()
                for q in self.queue_set:
                    try:
                        if q.filter_f(item):
                            q.put_nowait(item)
                    except asyncio.QueueFull:
                        pass
                    except Exception:
                        logger.exception("exception in filter_f")
        self.run_task = asyncio.Task(f(), loop=loop)

    def new_q(self, filter_f=lambda o: True, maxsize=0):
        q = asyncio.Queue(maxsize=maxsize, loop=self.loop)
        q.filter_f = filter_f
        self.queue_set.add(q)
        self.event_queue_nonempty.set()
        return q.get

    def remove_q(self, q):
        # this is mostly for testing. It ensures that
        # the queue_set has discarded the given q.
        # It's difficult to ensure that the WeakSet
        # will release the unreferenced object otherwise.
        self.queue_set.discard(getattr(q, "__self__"))

    def cancel(self):
        self.is_running = False
